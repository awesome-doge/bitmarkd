#!/bin/sh
# recreate fault.go from all go files
# scans all go files and created correponding error messages
# using the following method:
# each:
#   fault.MessageWithCapitalisedWords
# produces a var with a lower case message string:
#   MessageWithCapitalisedWords = e("message with capitalised words")


program=$(basename "$0")
this_dir=$(dirname "$0")
root_dir=$(realpath "${this_dir}/..")
year=$(date '+%Y')
date=$(date '+%F %T')
file=$(realpath "${this_dir}/fault.go")

header='// SPDX-License-Identifier: ISC
// Copyright (c) 2014-'"${year}"' Bitmark Inc.
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

// *************************************
// *** GENERATED FILE: DO NOT MODIFY ***
// *************************************

// generated by:   '"${program}"'
// generated on:   '"${date}"'

package fault

import "errors"

func e(s string) error {
	return errors.New(s)
}
'

a='
  BEGIN {
    maximum_length = 0
  }
  END {
    # this must sort first
    printf "!!!! %d\n", maximum_length
  }
  {
    s = $0
    while (match(s, "fault[.][[:alnum:]]+")) {
      w = substr(s, RSTART, RLENGTH)
      sub("^fault[.]", "", w)
      print w
      l = length(w)
      if (l > maximum_length) {
        maximum_length = l
      }
      s = substr(s, RSTART+RLENGTH)
    }
  }
'

b='
  BEGIN {
    printf "// auto generated error vars: *** DO NOT MODIFY ***\n"
    printf "\nvar (\n"
    maximum_length = 0
  }

  END {
    printf ")\n"
  }

  /^!!!!/ {
    maximum_length = $2
  }

  /^[[:upper:]]/ {
    e = $0
    w = $0
    gsub("([[:upper:]])", " &", w)
    sub("^ ", "", w)
    printf ("\t%-" maximum_length "s = e(\"%s\")\n"), e, tolower(w)
  }
'

printf '%s' "${header}" > "${file}"
find "${root_dir}" -name '*.go' -exec grep 'fault[.][[:upper:]]' '{}' ';' | awk "${a}" | sort -u | awk "${b}" >> "${file}"
